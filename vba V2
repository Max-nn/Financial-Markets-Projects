import datetime
from datetime import timedelta
import numpy as np
import scipy.stats as si
from scipy.optimize import minimize
from scipy.interpolate import interp1d
from pandas.tseries.offsets import BDay
import blpapi as blp
from blpapi import SessionOptions, Session
import pdblp
import pandas as pd
import QuantLib as ql

# --- 1. Load Data and Connect to Bloomberg ---
# Import deals data using pd.read
deals_data= pd.read_excel('ProjetBBG.xlsx')

# We create the risk dataframe
risk_monitor = deals_data.copy()

# We initiate connexion with BBG
con = pdblp.BCon(port=8194)
con.start()

# --- 2. Get Market Data for Options & Underlyings ---
# Define tickers and fields to find
tickers = risk_monitor['Ticker']

# Fields
option_tickers = risk_monitor['Ticker']
option_fields = [
    'BID', 'ASK', 'PX_LAST',
    'OPT_IMPLIED_VOLATILITY_MID', # BSM Log-Normal Vol
    'OPT_IMPLIED_VOLATILITY_NORMAL_MID' # Bachelier/Normal Vol (in BPS)
]

risk_monitor[['Opt_Bid', 'Opt_Ask', 'Opt_Last', 'IV', 'IV_Normal_BPS']] = con.ref(
    option_tickers.tolist(), option_fields
)

# Convert to decimal
risk_monitor['IV'] = risk_monitor['IV'] / 100.0
# <-- NEW: Convert Normal Vol from BPS (e.g., 8000) to decimal (e.g., 0.80)
risk_monitor['IV_Normal'] = risk_monitor['IV_Normal_BPS'] / 10000.0

sigma = risk_monitor['IV']
sigma_norm = risk_monitor['IV_Normal'] # This is our 'sigma' for Bachelier

# Get key inputs for BSM calculations
#Timing
today = datetime.date.today()
# TIME TO MATURITY T
exp_date= pd.to_datetime(risk_monitor['Maturity']).dt.date
trading_days_delta = exp_date.apply(lambda x: np.busday_count(today, x)) # calculates nb of trading day between today and exp
risk_monitor['TradingDaysToMat'] = trading_days_delta
T= risk_monitor['TradingDaysToMat']/252 # Time to maturity (in years)
risk_monitor['T'] = T

# We import historical price data with BBG
company_tickers= deals_data['Ticker'].str.split(' ').str[0] + ' Equity'#We keep only the ticker part of the column
company_fields = ['PX_LAST', 'DIVIDEND_YIELD']
# Create a temporary dataframe for underlying data
underlying_data = con.ref(company_tickers.unique().tolist(), company_fields)

# Map this data back to our main risk_monitor DataFrame
# We create a mapping dict from the index (e.g., 'AAPL Equity')
s0_map = underlying_data['PX_LAST'].to_dict()
q_map = (underlying_data['DIVIDEND_YIELD'] / 100.0).to_dict() # Convert dividend to decimal

risk_monitor['S'] = company_tickers.map(s0_map)
risk_monitor['q'] = company_tickers.map(q_map) # 'q' is the dividend yield
risk_monitor['q'] = risk_monitor['q'].fillna(0) # Assume 0 dividend if BBG returns NaN

start_date = str(today - BDay(trading_days_delta.max()))
end_date = str(today - timedelta(days=1))
periodicity = 'DAILY'
df_hist_close_price = con.bdh(
        company_tickers,
        company_fields,
        start_date,
        end_date,
        periodicitySelection= periodicity
    )
print(df_hist_close_price.head()) #inspect the data

# --- 3. Calculate Key BSM Inputs (K, T) ---
# STRIKE K
K = risk_monitor['Strike Px']

# Historical volatility calculation
log_returns = np.log(df_hist_close_price['PX_LAST'] / df_hist_close_price['PX_LAST'].shift(1))
hist_volatility = log_returns.std() * np.sqrt(252)

# --- 4. TASK 2: Compute the Yield Curve using US Govies (r) ---

print("---Fetching US Treasury yield curve---")
# Define the tickers for the US Treasury "Actives" curve
# We get key points on the curve to build our interpolation
curve_tickers = {
    'US0001M Index': 1/12.0,  # 1 Month
    'US0003M Index': 3/12.0,  # 3 Month
    'US0006M Index': 6/12.0,  # 6 Month
    'USGG1YR Index': 1.0,     # 1 Year
    'USGG2YR Index': 2.0,     # 2 Year
    'USGG5YR Index': 5.0,     # 5 Year
    'USGG10YR Index': 10.0,   # 10 Year
}

# Fetch the last price (which is the yield) for these tickers
curve_data = con.ref(list(curve_tickers.keys()), ['PX_LAST'])

# Create a clean list of (time, rate) points for interpolation
# .values.flatten() converts the DataFrame column to a simple list
# We sort by time to ensure the interpolation works
curve_points_T = sorted(curve_tickers.values())
curve_points_r = (curve_data['PX_LAST'] / 100.0).sort_index().values # Convert to decimal

# Create an interpolation function
# 'interp1d' builds a function that can find any 'y' (rate) for a given 'x' (time)
# 'fill_value="extrapolate"' allows us to get rates for maturities outside our 1M-10Y range
yield_curve_func = interp1d(
    curve_points_T,
    curve_points_r,
    kind='linear', # 'linear' interpolation is standard
    fill_value="extrapolate"
)

# Now, apply this function to our 'T' (time to maturity) column to get the risk-free rate
risk_monitor['r'] = risk_monitor['T'].apply(yield_curve_func)
r = risk_monitor['r']

# --- 5. TASK 1: Compute the Greeks (BSM Functions) ---

print("--Calculating Greeks--")


def d1(S, K, T, r, q, sigma):
    """Calculates d1 for the BSM model"""
    return (np.log(S / K) + (r - q + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))


def d2(S, K, T, r, q, sigma):
    """Calculates d2 for the BSM model"""
    return d1(S, K, T, r, q, sigma) - sigma * np.sqrt(T)


def bsm_delta(S, K, T, r, q, sigma, option_type):
    """Calculates Delta of an option"""
    d1_val = d1(S, K, T, r, q, sigma)
    if option_type == 'C':
        return np.exp(-q * T) * si.norm.cdf(d1_val)
    elif option_type == 'P':
        return -np.exp(-q * T) * si.norm.cdf(-d1_val)


def bsm_gamma(S, K, T, r, q, sigma):
    """Calculates Gamma of an option"""
    d1_val = d1(S, K, T, r, q, sigma)
    pdf_d1 = si.norm.pdf(d1_val)
    return (np.exp(-q * T) * pdf_d1) / (S * sigma * np.sqrt(T))


def bsm_vega(S, K, T, r, q, sigma):
    """Calculates Vega of an option (per 1% vol change)"""
    d1_val = d1(S, K, T, r, q, sigma)
    pdf_d1 = si.norm.pdf(d1_val)
    # This is Vega per 1.0 vol change, divide by 100 for Vega per 1% change
    return (S * np.exp(-q * T) * pdf_d1 * np.sqrt(T)) / 100.0


def bsm_theta(S, K, T, r, q, sigma, option_type):
    """Calculates Theta of an option (per calendar day)"""
    d1_val = d1(S, K, T, r, q, sigma)
    d2_val = d2(S, K, T, r, q, sigma)
    pdf_d1 = si.norm.pdf(d1_val)

    if option_type == 'C':
        theta = (- (S * np.exp(-q * T) * pdf_d1 * sigma) / (2 * np.sqrt(T))
                 - r * K * np.exp(-r * T) * si.norm.cdf(d2_val)
                 + q * S * np.exp(-q * T) * si.norm.cdf(d1_val))
    elif option_type == 'P':
        theta = (- (S * np.exp(-q * T) * pdf_d1 * sigma) / (2 * np.sqrt(T))
                 + r * K * np.exp(-r * T) * si.norm.cdf(-d2_val)
                 - q * S * np.exp(-q * T) * si.norm.cdf(-d1_val))

    # Return Theta per day (divide by 252 trading days)
    return theta / 252

def bsm_rho(S, K, T, r, q, sigma, option_type):
    """Calculates Rho of an option (per 1% rate change)"""
    d2_val = d2(S, K, T, r, q, sigma)
    if option_type == 'C':
        rho = K * T * np.exp(-r * T) * si.norm.cdf(d2_val)
    elif option_type == 'P':
        rho = -K * T * np.exp(-r * T) * si.norm.cdf(-d2_val)

    # Return Rho per 1% change (divide by 100)
    return rho / 100.0

# --- 6. Apply Greeks Functions to the DataFrame ---

# We can't use .apply() easily because we have multiple columns.
# vectorization is faster than looping
S_vec = risk_monitor['S']
K_vec = risk_monitor['Strike Px']
T_vec = risk_monitor['T']
r_vec = risk_monitor['r']
q_vec = risk_monitor['q']
sigma_vec = risk_monitor['IV']
type_vec = risk_monitor['Type']

risk_monitor['Delta'] = bsm_delta(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_vec, type_vec)
risk_monitor['Gamma'] = bsm_gamma(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_vec)
risk_monitor['Vega'] = bsm_vega(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_vec)
risk_monitor['Theta'] = bsm_theta(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_vec, type_vec)
risk_monitor['Rho'] = bsm_rho(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_vec, type_vec)

# --- 7. Bachelier Model ---
print("--Calculating Bachelier (Normal Model) Greeks--")

def bachelier_d(S, K, T, r, q, sigma_norm):
    """Calculates 'd' for the Bachelier/Normal model"""
    # Use the Forward price
    F = S * np.exp((r - q) * T)
    return (F - K) / (sigma_norm * S * np.sqrt(T)) # sigma_norm is % vol

def bachelier_delta(S, K, T, r, q, sigma_norm, option_type):
    """Calculates Delta for the Bachelier/Normal model"""
    d_val = bachelier_d(S, K, T, r, q, sigma_norm)
    delta_fwd = si.norm.cdf(d_val) if option_type == 'C' else -si.norm.cdf(-d_val)
    # Convert Delta (w.r.t Forward) to Delta (w.r.t Spot)
    return np.exp((r - q) * T) * delta_fwd * (1 + sigma_norm * (d_val / np.sqrt(T)))

def bachelier_gamma(S, K, T, r, q, sigma_norm):
    """Calculates Gamma for the Bachelier/Normal model"""
    d_val = bachelier_d(S, K, T, r, q, sigma_norm)
    pdf_d = si.norm.pdf(d_val)
    return (np.exp((r - q) * T) * pdf_d) / (sigma_norm * S * np.sqrt(T))

# --- Apply Bachelier Greeks ---
bachelier_greeks_df = risk_monitor[['Ticker', 'Last Price', 'Strike Px','Opt_Bid', 'Opt_Ask', 'Opt_Last']].copy()
sigma_norm_vec = risk_monitor['IV_Normal']
bachelier_greeks_df['Delta_Bach'] = bachelier_delta(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_norm_vec, type_vec)
bachelier_greeks_df['Gamma_Bach'] = bachelier_gamma(S_vec, K_vec, T_vec, r_vec, q_vec, sigma_norm_vec)
print(bachelier_greeks_df)

# --- 4.5 NEW: Prepare Data for Heston Calibration ---
print("\n--- Preparing Data for Calibration ---")

# Calculate mid-price to calibrate against
risk_monitor['Market_Price'] = (risk_monitor['Opt_Bid'] + risk_monitor['Opt_Ask']) / 2.0

# Filter out bad data. We need valid bid/ask and a positive market price.
calibration_data = risk_monitor[
    (risk_monitor['Opt_Bid'] > 0) &
    (risk_monitor['Opt_Ask'] > 0) &
    (risk_monitor['Market_Price'] > 0.01) # Avoid zero-priced options
].copy()
ql_today = ql.Date(today.day, today.month, today.year)
ql.Settings.instance().evaluationDate = ql_today

# --- 7. ### NEW: Heston Model CALIBRATION ---
print("\n--- Starting Heston Calibration ---")
# We must calibrate parameters PER UNDERLYING.
# This dict will store the calibrated params for each stock
calibrated_params_map = {}
underlying_tickers = risk_monitor['S_Ticker'].unique()

for ticker in underlying_tickers:
    print(f"\nCalibrating for: {ticker}")

    # 1. Get the data for this underlying
    options_for_ticker = calibration_data[
        calibration_data['S_Ticker'] == ticker
        ].copy()

    if len(options_for_ticker) < 5:  # Need a minimum number of options
        print(f"Skipping {ticker}, not enough data points ({len(options_for_ticker)})")
        calibrated_params_map[ticker] = None  # Mark as failed
        continue


    # --- 2. Define the Objective (Loss) Function ---
    # This function will be minimized by SciPy
    def heston_calibration_loss(params):
        """
        Takes Heston params [v0, kappa, theta, sigma_v, rho]
        and returns the RMSE between model prices and market prices.
        """
        v0, kappa, theta, sigma_v, rho = params
        model_prices = []

        try:
            # We loop over our pre-filtered options for this ticker
            for _, row in options_for_ticker.iterrows():
                # 1. Set up QL objects for this option
                ql_expiry = ql.Date(row['Maturity'].day, row['Maturity'].month, row['Maturity'].year)
                payoff = ql.PlainVanillaPayoff(ql.Option.Call if row['Type'] == 'C' else ql.Option.Put,
                                               row['Strike Px'])
                exercise = ql.EuropeanExercise(ql_expiry)
                option = ql.VanillaOption(payoff, exercise)

                # 2. Set up market data handles
                spot_handle_opt = ql.QuoteHandle(ql.SimpleQuote(row['S']))
                rate_handle_opt = ql.YieldTermStructureHandle(ql.FlatForward(ql_today, row['r'], ql.Actual365Fixed()))
                div_handle_opt = ql.YieldTermStructureHandle(ql.FlatForward(ql_today, row['q'], ql.Actual365Fixed()))

                # 3. Set up Heston Model *with the test parameters*
                heston_process = ql.HestonProcess(rate_handle_opt, div_handle_opt, spot_handle_opt, v0, kappa, theta,
                                                  sigma_v, rho)
                heston_model = ql.HestonModel(heston_process)
                engine = ql.AnalyticHestonEngine(heston_model)
                option.setPricingEngine(engine)

                model_prices.append(option.NPV())

        except Exception as e:
            # Optimizer supplied bad parameters (e.g. Feller condition violation)
            # print(f"Warning: QL Error with params {params}: {e}") # Uncomment for debug
            return 1e9  # Return a huge error to penalize this

        # 4. Calculate error (RMSE)
        model_prices = np.array(model_prices)
        market_prices_np = options_for_ticker['Market_Price'].values

        # Check for NaN/Inf in model prices, which can happen with bad params
        if not np.all(np.isfinite(model_prices)):
            return 1e9  # Penalize

        error = np.sqrt(np.mean((model_prices - market_prices_np) ** 2))

        # print(f"Trying params: {params}, Error: {error}") # Uncomment for debug
        return error


    # --- 3. Run the Optimization ---
    # Initial guesses (your placeholder values)
    initial_params = [0.06, 0.1, 0.05, 0.1, -0.7]  # v0, kappa, theta, sigma_v, rho

    # Bounds for the parameters (v0, kappa, theta, sigma_v, rho)
    # These are critical for a stable optimization
    bounds = [
        (1e-5, 1.0),  # v0 (initial variance)
        (1e-3, 20.0),  # kappa (mean reversion speed)
        (1e-5, 1.0),  # theta (long-run variance)
        (1e-3, 2.0),  # sigma_v (vol of vol)
        (-0.99, 0.99)  # rho (correlation)
    ]

    print(f"Starting optimization for {ticker} with {len(options_for_ticker)} options...")

    # Use 'L-BFGS-B' as it's fast and handles bounds
    result = minimize(
        heston_calibration_loss,
        initial_params,
        method='L-BFGS-B',
        bounds=bounds,
        options={'maxiter': 200, 'ftol': 1e-7}  # 'ftol' is function tolerance
    )

    if result.success:
        calibrated_params = result.x
        print(f"--- Calibration SUCCESS for {ticker} ---")
        print(f"  v0 (Initial Var)  = {calibrated_params[0]:.6f}")
        print(f"  kappa (Reversion) = {calibrated_params[1]:.6f}")
        print(f"  theta (Long Var)  = {calibrated_params[2]:.6f}")
        print(f"  sigma_v (VolofVol) = {calibrated_params[3]:.6f}")
        print(f"  rho (Correlation) = {calibrated_params[4]:.6f}")
        print(f"  Final RMSE (price error): {result.fun:.6f}")

        # Store them in our map
        calibrated_params_map[ticker] = {
            'v0': calibrated_params[0],
            'kappa': calibrated_params[1],
            'theta': calibrated_params[2],
            'sigma_v': calibrated_params[3],
            'rho': calibrated_params[4]
        }
    else:
        print(f"--- Calibration FAILED for {ticker} ---")
        print(f"  Message: {result.message}")
        calibrated_params_map[ticker] = None  # Mark as failed

# --- END OF CALIBRATION LOOP ---


# --- 8. ### MODIFIED: Heston Model (via QuantLib) ---
print("\n--Calculating Heston Greeks (using CALIBRATED params)--")


# -- Heston Parameters --
# ### MODIFIED: We delete the hard-coded values.
# v0 = 0.06  ...etc...

def calculate_heston_greeks(row):
    """
    ### MODIFIED:
    This function now looks up the calibrated parameters
    for the specific underlying of the option row.
    """

    # --- 0. Get the calibrated params for this row's underlying ---
    underlying_ticker = row['S_Ticker']
    params = calibrated_params_map.get(underlying_ticker)

    if params is None:
        # Calibration failed or was skipped for this ticker
        return pd.Series(dtype='float64')  # Return NaNs

    # Unpack the params
    v0 = params['v0']
    kappa = params['kappa']
    theta = params['theta']
    sigma_v = params['sigma_v']
    rho = params['rho']

    # 1. Set up QuantLib objects for this option
    # ql_today is already set globally
    ql_expiry = ql.Date(row['Maturity'].day, row['Maturity'].month, row['Maturity'].year)

    payoff = ql.PlainVanillaPayoff(
        ql.Option.Call if row['Type'] == 'C' else ql.Option.Put,
        row['Strike Px']
    )
    exercise = ql.EuropeanExercise(ql_expiry)
    option = ql.VanillaOption(payoff, exercise)

    # 2. Set up market data handles
    spot_handle = ql.QuoteHandle(ql.SimpleQuote(row['S']))
    rate_handle = ql.YieldTermStructureHandle(ql.FlatForward(ql_today, row['r'], ql.Actual365Fixed()))
    div_handle = ql.YieldTermStructureHandle(ql.FlatForward(ql_today, row['q'], ql.Actual365Fixed()))

    # 3. Set up Heston Model
    heston_process = ql.HestonProcess(rate_handle, div_handle, spot_handle, v0, kappa, theta, sigma_v, rho)
    heston_model = ql.HestonModel(heston_process)

    # Use a high-quality pricing engine
    engine = ql.AnalyticHestonEngine(heston_model)
    option.setPricingEngine(engine)

    # 4. Calculate and return Greeks
    try:
        return pd.Series({
            'Delta_Heston': option.delta(),
            'Gamma_Heston': option.gamma(),
            'Vega_Heston': option.vega() / 100.0,  # Per 1% vol change
            'Theta_Heston': option.theta() / 365.25  # Per day
        })
    except Exception as e:
        print(f"QuantLib Error for {row.name} (Ticker: {underlying_ticker}): {e}")
        return pd.Series(dtype='float64')


# Apply the Heston function to each row
heston_greeks_df = risk_monitor.apply(calculate_heston_greeks, axis=1)

# Merge the results back into the main DataFrame
risk_monitor = pd.concat([risk_monitor, heston_greeks_df], axis=1)

# --- Final Output ---
print("\n--- Risk Monitor with Greeks ---")
# ### MODIFIED: Add Heston greeks to the final output
final_columns = [
    'Type', 'S', 'Strike Px', 'Maturity', 'Opt_Bid', 'Opt_Ask', 'Opt_Last', 'IV',
    'Delta', 'Gamma', 'Vega', 'Theta', 'Rho',
    'Delta_Heston', 'Gamma_Heston', 'Vega_Heston', 'Theta_Heston'
]
# Filter for columns that actually exist, in case some failed
final_columns_exist = [col for col in final_columns if col in risk_monitor.columns]
print(risk_monitor[final_columns_exist].to_string(float_format="%.4f"))

# Optional: Save to Excel
# risk_monitor.to_excel("Risk_Monitor_with_Greeks.xlsx")

print("\nScript completed.")

# Stop the Bloomberg connection
con.stop()
